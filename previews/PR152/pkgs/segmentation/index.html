<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ImageSegmentation.jl · JuliaImages</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../democards/gridtheme.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaImages logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuliaImages</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Getting started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/quickstart/">Quickstart</a></li><li><a class="tocitem" href="../../tutorials/arrays_colors/">Arrays, Numbers, and Colors</a></li><li><a class="tocitem" href="../../tutorials/conversions_views/">Conversions vs. views</a></li><li><a class="tocitem" href="../../tutorials/indexing/">Arrays: more advanced indexing</a></li></ul></li><li><span class="tocitem">Packages</span><ul><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../axes/">ImageAxes.jl</a></li><li><a class="tocitem" href="../metadata/">ImageMetaData.jl</a></li><li class="is-active"><a class="tocitem" href>ImageSegmentation.jl</a><ul class="internal"><li><a class="tocitem" href="#Introduction-1"><span>Introduction</span></a></li><li><a class="tocitem" href="#Installation-1"><span>Installation</span></a></li><li><a class="tocitem" href="#Example-1"><span>Example</span></a></li><li><a class="tocitem" href="#Result-1"><span>Result</span></a></li><li><a class="tocitem" href="#Algorithms-1"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Some-helpful-functions-1"><span>Some helpful functions</span></a></li></ul></li><li><a class="tocitem" href="../transformations/">ImageTransformations.jl</a></li><li><a class="tocitem" href="../features/">ImageFeatures.jl</a></li></ul></li><li><a class="tocitem" href="../../democards/examples/">Demos</a></li><li><a class="tocitem" href="../../function_reference/">References</a></li><li><a class="tocitem" href="../../api_comparison/">Comparison with other image processing frameworks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Packages</a></li><li class="is-active"><a href>ImageSegmentation.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ImageSegmentation.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/juliaimages.github.io/blob/source/docs/src/pkgs/segmentation/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ImageSegmentation.jl-1"><a class="docs-heading-anchor" href="#ImageSegmentation.jl-1">ImageSegmentation.jl</a><a class="docs-heading-anchor-permalink" href="#ImageSegmentation.jl-1" title="Permalink"></a></h1><h2 id="Introduction-1"><a class="docs-heading-anchor" href="#Introduction-1">Introduction</a><a class="docs-heading-anchor-permalink" href="#Introduction-1" title="Permalink"></a></h2><p>Image Segmentation is the process of partitioning the image into regions that have similar attributes. Image segmentation has various applications e.g, medical image segmentation, image compression and is used as a preprocessing step in higher level vision tasks like object detection and optical flow. This package is a collection of image segmentation algorithms written in Julia.</p><h2 id="Installation-1"><a class="docs-heading-anchor" href="#Installation-1">Installation</a><a class="docs-heading-anchor-permalink" href="#Installation-1" title="Permalink"></a></h2><pre><code class="language-julia">(v1.0) pkg&gt; add ImageSegmentation</code></pre><h2 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h2><p>Image segmentation is not a mathematically well-defined problem: for example, the only lossless representation of the input image would be to say that each pixel is its own segment. Yet this does not correspond to our own intuitive notion that some pixels are naturally grouped together. As a consequence, many algorithms require parameters, often some kind of threshold expressing your willingness to tolerate a certain amount of variation among the pixels within a single segment.</p><p>Let&#39;s see an example on how to use the segmentation algorithms in this package. We will try to separate the horse, the ground and the sky in the image below. We will explore two algorithms - seeded region growing and felzenszwalb. Seeded region growing requires us to know the number of segments and some points on each segment beforehand whereas felzenszwalb uses a more abstract parameter controlling degree of within-segment similarity.</p><p><img src="assets/horse.jpg" alt="Original"/></p><p><a href="https://ibb.co/hUQMnQ">source</a></p><p>The documentation for <code>seeded_region_growing</code> says that it needs two arguments - the image to be segmented and a set of seed points for each region. The seed points have to be stored as a vector of <code>(position, label)</code> tuples, where <code>position</code> is a <a href="https://docs.julialang.org/en/stable/manual/arrays/#Cartesian-indices-1"><code>CartesianIndex</code></a> and <code>label</code> is an integer. We will start by opening the image using ImageView and reading the coordinates of the seed points.</p><pre><code class="language-julia">using Images, ImageView

img = load(&quot;src/pkgs/segmentation/assets/horse.jpg&quot;)
imshow(img)</code></pre><p>Hover over the different objects you&#39;d like to segment, and read out the coordinates of one or more points inside each object. We will store the seed points as a vector of <code>(seed position, label)</code> tuples and use <code>seeded_region_growing</code> with the recorded seed points.</p><pre><code class="language-julia">using ImageSegmentation
seeds = [(CartesianIndex(126,81),1), (CartesianIndex(93,255),2), (CartesianIndex(213,97),3)]
segments = seeded_region_growing(img, seeds)

# output

Segmented Image with:
  labels map: 240×360 Array{Int64,2}
  number of labels: 3</code></pre><p>All the segmentation algorithms (except Fuzzy C-means) return a struct <code>SegmentedImage</code> that stores the segmentation result. <code>SegmentedImage</code> contains a list of applied labels, an array containing the assigned label for each pixel, and mean color and number of pixels in each segment. <a href="#Result-1">This section</a> explains how to access information about the segments.</p><pre><code class="language-julia-repl">julia&gt; length(segment_labels(segments))
3

julia&gt; segment_mean(segments)
Dict{Int64,RGB{Float64}} with 3 entries:
  2 =&gt; RGB{Float64}(0.793598,0.839543,0.932374)
  3 =&gt; RGB{Float64}(0.329863,0.35779,0.237457)
  1 =&gt; RGB{Float64}(0.0646509,0.0587034,0.0743471)</code></pre><p>We can visualize each segment using its mean color:</p><pre><code class="language-julia">julia&gt; imshow(map(i-&gt;segment_mean(segments,i), labels_map(segments)));</code></pre><p><img src="assets/horse_seg1.jpg" alt="Original"/></p><p>This display form is used for many of the demonstrations below.</p><p>You can see that the algorithm did a fairly good job of segmenting the three objects. The only obvious error is the fact that elements of the sky that were &quot;framed&quot; by the horse ended up being grouped with the ground. This is because <code>seeded_region_growing</code> always returns connected regions, and there is no path connecting those portions of sky to the larger image. If we add some additional seed points in those regions, and give them the same label <code>2</code> that we used for the rest of the sky, we will get a result that is more or less perfect.</p><pre><code class="language-julia">seeds = [(CartesianIndex(126,81), 1), (CartesianIndex(93,255), 2), (CartesianIndex(171,103), 2),
         (CartesianIndex(172,142), 2), (CartesianIndex(182,72), 2), (CartesianIndex(213,97), 3)]
segments = seeded_region_growing(img, seeds)</code></pre><p><img src="assets/horse_seg5.jpg" alt="Original"/></p><p>Now let&#39;s segment this image using felzenszwalb algorithm. <code>felzenswalb</code> only needs a single parameter <code>k</code> which controls the size of segments. Larger <code>k</code> will result in bigger segments. Using <code>k=5</code> to <code>k=500</code> generally gives good results.</p><pre><code class="language-julia-repl">julia&gt; using Images, ImageSegmentation

julia&gt; img = load(&quot;src/pkgs/segmentation/assets/horse.jpg&quot;);

julia&gt; segments = felzenszwalb(img, 100)
Segmented Image with:
  labels map: 240×360 Array{Int64,2}
  number of labels: 43

julia&gt; segments = felzenszwalb(img, 10)  #smaller segments but noisy segmentation
Segmented Image with:
  labels map: 240×360 Array{Int64,2}
  number of labels: 312</code></pre><table><tr><th style="text-align: center">k = 100</th><th style="text-align: center">k = 10</th></tr><tr><td style="text-align: center"><img src="assets/horse_seg2.jpg" alt="Original"/></td><td style="text-align: center"><img src="assets/horse_seg3.jpg" alt="Original"/></td></tr></table><p>We only got two &quot;major&quot; segments with <code>k = 100</code>. Setting <code>k = 10</code> resulted in smaller but rather noisy segments. <code>felzenzwalb</code> also takes an optional argument <code>min_size</code> - it removes all segments smaller than <code>min_size</code> pixels. (Most methods don&#39;t remove small segments in their core algorithm. We can use the <code>prune_segments</code> method to postprocess the segmentation result and remove small segments.)</p><pre><code class="language-julia">segments = felzenszwalb(img, 10, 100)  # removes segments with fewer than 100 pixels
imshow(map(i-&gt;segment_mean(segments,i), labels_map(segments)))</code></pre><p><img src="assets/horse_seg4.jpg" alt="Original"/></p><h2 id="Result-1"><a class="docs-heading-anchor" href="#Result-1">Result</a><a class="docs-heading-anchor-permalink" href="#Result-1" title="Permalink"></a></h2><p>All segmentation algorithms (except Fuzzy C-Means) return a struct <a href="../../function_reference/#ImageSegmentation.SegmentedImage"><code>SegmentedImage</code></a> as its output. <code>SegmentedImage</code> contains all the necessary information about the segments. The following functions can be used to get the information about the segments:</p><ol><li><a href="../../function_reference/#ImageSegmentation.labels_map"><code>labels_map</code></a> : It returns an array containing the labels assigned to each pixel</li><li><a href="../../function_reference/#ImageSegmentation.segment_labels"><code>segment_labels</code></a> : It returns a list of all the assigned labels</li><li><a href="../../function_reference/#ImageSegmentation.segment_mean"><code>segment_mean</code></a> : It returns the mean intensity of the supplied label.</li><li><a href="../../function_reference/#ImageSegmentation.segment_pixel_count"><code>segment_pixel_count</code></a> : It returns the count of the pixels that are assigned the supplied label.</li></ol><h6 id="Demo-1"><a class="docs-heading-anchor" href="#Demo-1">Demo</a><a class="docs-heading-anchor-permalink" href="#Demo-1" title="Permalink"></a></h6><pre><code class="language-julia-repl">julia&gt; img = fill(1, 4, 4);

julia&gt; img[1:2,1:2] .= 2;

julia&gt; img
4×4 Array{Int64,2}:
 2  2  1  1
 2  2  1  1
 1  1  1  1
 1  1  1  1

julia&gt; seg = fast_scanning(img, 0.5);

julia&gt; labels_map(seg) # returns the assigned labels map
4×4 Array{Int64,2}:
 1  1  3  3
 1  1  3  3
 3  3  3  3
 3  3  3  3

julia&gt; segment_labels(seg) # returns a list of all assigned labels
2-element Array{Int64,1}:
 1
 3

julia&gt; segment_mean(seg, 1) # returns the mean intensity of label 1
2.0

julia&gt; segment_pixel_count(seg, 1) # returns the pixel count of label 1
4</code></pre><h2 id="Algorithms-1"><a class="docs-heading-anchor" href="#Algorithms-1">Algorithms</a><a class="docs-heading-anchor-permalink" href="#Algorithms-1" title="Permalink"></a></h2><h4 id="Seeded-Region-Growing-1"><a class="docs-heading-anchor" href="#Seeded-Region-Growing-1">Seeded Region Growing</a><a class="docs-heading-anchor-permalink" href="#Seeded-Region-Growing-1" title="Permalink"></a></h4><p>Seeded region growing segments an image with respect to some user-defined seeds. Each seed is a <code>(position, label)</code> tuple, where <code>position</code> is a <a href="https://docs.julialang.org/en/stable/manual/arrays/#Cartesian-indices-1"><code>CartesianIndex</code></a> and <code>label</code> is a positive integer. Each label corresponds to a unique partition of the image. The algorithm tries to assign these labels to each of the remaining points. If more than one point has the same label then they will be contribute to the same segment.</p><h6 id="Demo-2"><a class="docs-heading-anchor" href="#Demo-2">Demo</a><a class="docs-heading-anchor-permalink" href="#Demo-2" title="Permalink"></a></h6><pre><code class="language-julia-repl">julia&gt; using Images, ImageSegmentation

julia&gt; img = load(&quot;src/pkgs/segmentation/assets/worm.jpg&quot;);

julia&gt; seeds = [(CartesianIndex(104, 48), 1), (CartesianIndex( 49, 40), 1),
                (CartesianIndex( 72,131), 1), (CartesianIndex(109,217), 1),
                (CartesianIndex( 28, 87), 2), (CartesianIndex( 64,201), 2),
                (CartesianIndex(104, 72), 2), (CartesianIndex( 86,138), 2)];

julia&gt; seg = seeded_region_growing(img, seeds)
Segmented Image with:
  labels map: 183×275 Array{Int64,2}
  number of labels: 2</code></pre><p><strong>Original</strong> <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Davidraju_Worm_Snake.jpg/275px-Davidraju_Worm_Snake.jpg">(source)</a>:</p><p><img src="assets/worm.jpg" alt="Original"/></p><p><strong>Segmented Image with labels replaced by their intensity means:</strong></p><p><img src="assets/worm_seg.jpg" alt="SegmentedImage"/></p><h4 id="Unseeded-Region-Growing-1"><a class="docs-heading-anchor" href="#Unseeded-Region-Growing-1">Unseeded Region Growing</a><a class="docs-heading-anchor-permalink" href="#Unseeded-Region-Growing-1" title="Permalink"></a></h4><p>This algorithm is similar to <a href="#Seeded-Region-Growing-1">Seeded Region Growing</a> but does not require any prior information about the seed points. The segmentation process initializes with region <span>$A_1$</span> containing a single pixel of the image. Let an intermediate state of the algorithm consist of a set of identified regions <span>$A_1, A_2, ..., A_n$</span>. Let <span>$T$</span> be the set of all unallocated pixels which borders at least one of these regions. The growing process involves selecting a point <span>$z \in T$</span> and region <span>$A_j$</span> where <span>$j \in [ \, 1,n ] \,$</span> such that</p><div>\[\delta ( \, z, A_j ) \, = min_{x \in T, k \in [ \, 1,n ] \, } \{ \delta ( \, x, A_k ) \, \}\]</div><p>where <span>$\delta ( \, x, A_i ) \, = | img ( \, x ) \, - mean_{y \in A_i} [ \, img ( \, y ) \, ] \, |$</span></p><p>If <span>$\delta ( \, z, A_j ) \,$</span> is less than <code>threshold</code> then the pixel <code>z</code> is added to <span>$A_j$</span>. Otherwise we choose the most similar region <span>$\alpha$</span> such that</p><div>\[\alpha = argmin_{A_k} \{ \delta ( \, z, A_k) \, \}\]</div><p>If <span>$\delta ( \, z, \alpha ) \,$</span> is less than <code>threshold</code> then the pixel <code>z</code> is added to <span>$\alpha$</span>. If neither of the two conditions is satisfied, then the pixel is assigned a new region <span>$A_{n+1}$</span>. After assignment of <span>$z$</span>, we update the statistic of the assigned region. The algorithm halts when all the pixels have been assigned to some region.</p><p><code>unseeded_region_growing</code> requires the image <code>img</code> and <code>threshold</code> as its parameters.</p><h6 id="Demo-3"><a class="docs-heading-anchor" href="#Demo-3">Demo</a><a class="docs-heading-anchor-permalink" href="#Demo-3" title="Permalink"></a></h6><pre><code class="language-julia-repl">julia&gt; using ImageSegmentation, Images

julia&gt; img = load(&quot;src/pkgs/segmentation/assets/tree.jpg&quot;);

julia&gt; seg = unseeded_region_growing(img, 0.05) # here 0.05 is the threshold
Segmented Image with:
  labels map: 320×480 Array{Int64,2}
  number of labels: 698</code></pre><table><tr><th style="text-align: right">Threshold</th><th style="text-align: right">Output</th><th style="text-align: right">Compression percentage</th></tr><tr><td style="text-align: right">Original <a href="http://maxpixel.freegreatpicture.com/static/photo/1x/Plant-Wood-Tissue-Leaves-Nature-Green-Tree-2387626.jpg">(source)</a></td><td style="text-align: right"><img src="assets/tree.jpg" alt="tree"/></td><td style="text-align: right">0 %</td></tr><tr><td style="text-align: right">0.05</td><td style="text-align: right"><img src="assets/tree_seg1.jpg" alt="tree_seg1"/></td><td style="text-align: right">60.63%</td></tr><tr><td style="text-align: right">0.1</td><td style="text-align: right"><img src="assets/tree_seg2.jpg" alt="tree_seg2"/></td><td style="text-align: right">71.27%</td></tr><tr><td style="text-align: right">0.2</td><td style="text-align: right"><img src="assets/tree_seg3.jpg" alt="tree_seg3"/></td><td style="text-align: right">79.96%</td></tr></table><h4 id="Felzenswalb&#39;s-Region-Merging-Algorithm-1"><a class="docs-heading-anchor" href="#Felzenswalb&#39;s-Region-Merging-Algorithm-1">Felzenswalb&#39;s Region Merging Algorithm</a><a class="docs-heading-anchor-permalink" href="#Felzenswalb&#39;s-Region-Merging-Algorithm-1" title="Permalink"></a></h4><p>This algorithm operates on a Region Adjacency Graph (RAG). Each pixel/region is a node in the graph and adjacent pixels/regions have edges between them with weight measuring the dissimilarity between pixels/regions. The algorithm repeatedly merges similar regions till we get the final segmentation. It efficiently computes oversegmented “superpixels” in an image. The function can be directly called with an image (the implementation internally creates a RAG of the image first and then proceeds).</p><h6 id="Demo-4"><a class="docs-heading-anchor" href="#Demo-4">Demo</a><a class="docs-heading-anchor-permalink" href="#Demo-4" title="Permalink"></a></h6><pre><code class="language-julia-repl">julia&gt; using Images, ImageSegmentation, TestImages

julia&gt; img = Gray.(testimage(&quot;house&quot;));

julia&gt; segments = felzenszwalb(img, 300, 100) # k=300 (the merging threshold), min_size = 100 (smallest number of pixels/region)
Segmented Image with:
  labels map: 512×512 Array{Int64,2}
  number of labels: 11</code></pre><p>Here let&#39;s visualize segmentation by creating an image with each label replaced by a random color:</p><pre><code class="language-julia">function get_random_color(seed)
    Random.seed!(seed)
    rand(RGB{N0f8})
end
imshow(map(i-&gt;get_random_color(i), labels_map(segments)))</code></pre><p><img src="assets/house.jpg" alt="img1"/> <img src="assets/felzenszwalb.jpg" alt="img2"/></p><h4 id="MeanShift-Segmentation-1"><a class="docs-heading-anchor" href="#MeanShift-Segmentation-1">MeanShift Segmentation</a><a class="docs-heading-anchor-permalink" href="#MeanShift-Segmentation-1" title="Permalink"></a></h4><p>MeanShift is a clustering technique. Its primary advantages are that it doesn&#39;t assume a prior on the shape of the cluster (e.g, gaussian for k-means) and we don&#39;t need to know the number of clusters beforehand. The algorithm doesn&#39;t scale well with size of image.</p><h6 id="Demo-5"><a class="docs-heading-anchor" href="#Demo-5">Demo</a><a class="docs-heading-anchor-permalink" href="#Demo-5" title="Permalink"></a></h6><pre><code class="language-julia-repl">julia&gt; using Images, ImageSegmentation, TestImages

julia&gt; img = Gray.(testimage(&quot;house&quot;));

julia&gt; img = imresize(img, (128, 128));

julia&gt; segments = meanshift(img, 16, 8/255) # parameters are smoothing radii: spatial=16, intensity-wise=8/255
Segmented Image with:
  labels map: 128×128 Array{Int64,2}
  number of labels: 44</code></pre><p><img src="assets/small_house.jpg" alt="img1"/> <img src="assets/meanshift.jpg" alt="img2"/></p><h4 id="Fast-Scanning-1"><a class="docs-heading-anchor" href="#Fast-Scanning-1">Fast Scanning</a><a class="docs-heading-anchor-permalink" href="#Fast-Scanning-1" title="Permalink"></a></h4><p>Fast scanning algorithm segments the image by scanning it once and comparing each pixel to its upper and left neighbor. The algorithm starts from the first pixel and assigns it to a new segment <span>$A_1$</span>. Label count <code>lc</code> is assigned 1. Then it starts a column-wise traversal of the image and for every pixel, it computes the difference measure <code>diff_fn</code> between the pixel and its left neighbor, say <span>$\delta_{l}$</span> and between the pixel and its top neighbor, say <span>$\delta_{t}$</span>. Four cases arise:</p><ol><li><span>$\delta_{l}$</span> &gt;= <code>threshold</code> and <span>$\delta_{t}$</span> &lt; <code>threshold</code> : We can say that the point has similar intensity to that its top neighbor. Hence, we assign the point to the segment that contains its top neighbor.</li><li><span>$\delta_{l}$</span> &lt; <code>threshold</code> and <span>$\delta_{t}$</span> &gt;= <code>threshold</code> : Similar to case 1, we assign the point to the segment that contains its left neighbor.</li><li><span>$\delta_{l}$</span> &gt;= <code>threshold</code> and <span>$\delta_{t}$</span> &gt;= <code>threshold</code> : Point is significantly different from its top and left neighbors and is assigned a new label <span>$A_{lc+1}$</span> and <code>lc</code> is incremented.</li><li><span>$\delta_{l}$</span> &lt; <code>threshold</code> and <span>$\delta_{t}$</span> &lt; <code>threshold</code> : In this case, we merge the top and left semgents together and assign the point under consideration to this merged segment.</li></ol><p>This algorithm segments the image in just two passes (one for segmenting and other for merging), hence it is very fast and can be used in real time applications.</p><p><strong>Time Complexity:</strong> <span>$O(n)$</span> where <span>$n$</span> is the number of pixels</p><h6 id="Demo-6"><a class="docs-heading-anchor" href="#Demo-6">Demo</a><a class="docs-heading-anchor-permalink" href="#Demo-6" title="Permalink"></a></h6><pre><code class="language-julia-repl">julia&gt; using ImageSegmentation, TestImages

julia&gt; img = testimage(&quot;camera&quot;);

julia&gt; seg = fast_scanning(img, 0.1)  # threshold = 0.1
Segmented Image with:
  labels map: 512×512 Array{Int64,2}
  number of labels: 2538

julia&gt; seg = prune_segments(seg, i-&gt;(segment_pixel_count(seg,i)&lt;50), (i,j)-&gt;(-segment_pixel_count(seg,j)))
Segmented Image with:
  labels map: 512×512 Array{Int64,2}
  number of labels: 65</code></pre><p><strong>Original:</strong></p><p><img src="assets/camera.jpg" alt="Original"/></p><p><strong>Segmented Image:</strong></p><p><img src="assets/camera_seg.jpg" alt="SegmentedImage"/></p><h4 id="Region-Splitting-using-RegionTrees-1"><a class="docs-heading-anchor" href="#Region-Splitting-using-RegionTrees-1">Region Splitting using RegionTrees</a><a class="docs-heading-anchor-permalink" href="#Region-Splitting-using-RegionTrees-1" title="Permalink"></a></h4><p>This algorithm follows the divide and conquer methodology. If the input image is homogeneous then nothing is to be done. In the other case, the image is split into two across every dimension and the smaller parts are segmented recursively. This procedure generates a region tree which can be used to create a segmented image.</p><p><strong>Time Complexity:</strong> <span>$O(n*log(n))$</span> where <span>$n$</span> is the number of pixels</p><h6 id="Demo-7"><a class="docs-heading-anchor" href="#Demo-7">Demo</a><a class="docs-heading-anchor-permalink" href="#Demo-7" title="Permalink"></a></h6><pre><code class="language-julia-repl">julia&gt; using TestImages, ImageSegmentation

julia&gt; img = testimage(&quot;lena_gray&quot;);

julia&gt; function homogeneous(img)
           min, max = extrema(img)
           max - min &lt; 0.2
       end
homogeneous (generic function with 1 method)

julia&gt; seg = region_splitting(img, homogeneous)
Segmented Image with:
  labels map: 256×256 Array{Int64,2}
  number of labels: 8836</code></pre><p><strong>Original:</strong></p><p><img src="assets/lena.jpg" alt="Original"/></p><p><strong>Segmented Image with labels replaced by their intensity means:</strong></p><p><img src="assets/lena_seg.jpg" alt="SegmentedImage"/></p><h4 id="Fuzzy-C-means-1"><a class="docs-heading-anchor" href="#Fuzzy-C-means-1">Fuzzy C-means</a><a class="docs-heading-anchor-permalink" href="#Fuzzy-C-means-1" title="Permalink"></a></h4><p>Fuzzy C-means clustering is widely used for unsupervised image segmentation. It is an iterative algorithm which tries to minimize the cost function:</p><div>\[J = \displaystyle\sum_{i=1}^{N} \sum_{j=1}^{C} \delta_{ij} \| x_{i} - c_{j} \|^2\]</div><p>Unlike K-means, it allows pixels to belong to two or more clusters. It is widely used for medical imaging like in the soft segmentation of brain tissue model. Note that both Fuzzy C-means and K-means have an element of randomness, and it&#39;s possible to get results that vary considerably from one run to the next.</p><p><strong>Time Complexity:</strong> <span>$O(n*C^2*iter)$</span> where <span>$n$</span> is the number of pixels, <span>$C$</span> is number of clusters and <span>$iter$</span> is the number of iterations.</p><h6 id="Demo-8"><a class="docs-heading-anchor" href="#Demo-8">Demo</a><a class="docs-heading-anchor-permalink" href="#Demo-8" title="Permalink"></a></h6><pre><code class="language-julia-repl">julia&gt; using ImageSegmentation, Images

julia&gt; img = load(&quot;src/pkgs/segmentation/assets/flower.jpg&quot;);

julia&gt; r = fuzzy_cmeans(img, 3, 2)
FuzzyCMeansResult: 3 clusters for 135360 points in 3 dimensions (converged in 27 iterations)</code></pre><p>Briefly, <code>r</code> contains two fields of interest:</p><ul><li><code>centers</code>, a <code>3×C</code> matrix of center positions for <code>C</code> clusters in RGB colorspace. You can extract it as a vector of colors using <code>centers = colorview(RGB, r.centers)</code>.</li><li><code>weights</code>, a <code>n×C</code> matrix such that <code>r.weights[10,2]</code> would be the weight of the 10th pixel in the green color channel (color channel 2).  You can visualize this component as <code>centers[i]*reshape(r.weights[:,i], axes(img))</code>.</li></ul><p>See the documentation in <a href="https://github.com/JuliaStats/Clustering.jl">Clustering.jl</a> for further details.</p><p><strong>Original</strong> <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Flower-631765_960_720.jpg/800px-Flower-631765_960_720.jpg">(source)</a></p><p><img src="assets/flower.jpg" alt="Original"/></p><p><strong>Output with pixel intensity = cluster center intensity * membership of pixel in that class</strong></p><table><tr><th style="text-align: right">Magenta petals</th><th style="text-align: right">Greenish Leaves</th><th style="text-align: right">White background</th></tr><tr><td style="text-align: right"><img src="assets/flower_s1.jpg" alt="SegmentedImage1"/></td><td style="text-align: right"><img src="assets/flower_s2.jpg" alt="SegmentedImage2"/></td><td style="text-align: right"><img src="assets/flower_s3.jpg" alt="SegmentedImage3"/></td></tr></table><h4 id="Watershed-1"><a class="docs-heading-anchor" href="#Watershed-1">Watershed</a><a class="docs-heading-anchor-permalink" href="#Watershed-1" title="Permalink"></a></h4><p>The watershed algorithm treats an image as a topographic surface where bright pixels correspond to peaks and dark pixels correspond to valleys. The algorithm starts flooding from valleys (local minima) of this topographic surface and region boundaries are formed when water from different sources merge. If the image is noisy, this approach leads to oversegmetation. To prevent oversegmentation, marker-based watershed is used i.e. the topographic surface is flooded from a predefined set of markers.</p><p>Let&#39;s see an example on how to use watershed to segment touching objects. To use watershed, we need to modify the image such that in the new image flooding the topographic surface from the markers separates each coin. If this modified image is noisy, flooding from local minima may lead to oversegmentation and so we also need a way to find the marker positions. In this example, the inverted <a href="../../function_reference/#ImageMorphology.FeatureTransform.distance_transform"><code>distance_transform</code></a> of the thresholded image (<code>dist</code> image) has the required topographic structure (<a href="https://in.mathworks.com/company/newsletters/articles/the-watershed-transform-strategies-for-image-segmentation.html">This page</a> explains why this works). We can threshold the <code>dist</code> image to get the marker positions.</p><h6 id="Demo-9"><a class="docs-heading-anchor" href="#Demo-9">Demo</a><a class="docs-heading-anchor-permalink" href="#Demo-9" title="Permalink"></a></h6><pre><code class="language-julia-repl">julia&gt; using Images, ImageSegmentation

julia&gt; img = load(download(&quot;http://docs.opencv.org/3.1.0/water_coins.jpg&quot;));

julia&gt; bw = Gray.(img) .&gt; 0.5;

julia&gt; dist = 1 .- distance_transform(feature_transform(bw));

julia&gt; markers = label_components(dist .&lt; -15);

julia&gt; segments = watershed(dist, markers)
Segmented Image with:
  labels map: 312×252 Array{Int64,2}
  number of labels: 24

julia&gt; imshow(map(i-&gt;get_random_color(i), labels_map(segments)) .* (1 .-bw))       #shows segmented image</code></pre><table><tr><th style="text-align: center">Original Image</th><th style="text-align: center">Thresholded Image</th></tr><tr><td style="text-align: center"><img src="assets/water_coins.jpg" alt="img1"/></td><td style="text-align: center"><img src="assets/coins2.jpg" alt="img1"/></td></tr></table><table><tr><th style="text-align: center">Inverted Distance Transform Image</th><th style="text-align: center">Markers</th></tr><tr><td style="text-align: center"><img src="assets/coins3.jpg" alt="img1"/></td><td style="text-align: center"><img src="assets/coins4.jpg" alt="img1"/></td></tr></table><table><tr><th style="text-align: center">Segmented Image</th></tr><tr><td style="text-align: center"><img src="assets/watershed.jpg" alt="img2"/></td></tr></table><h2 id="Some-helpful-functions-1"><a class="docs-heading-anchor" href="#Some-helpful-functions-1">Some helpful functions</a><a class="docs-heading-anchor-permalink" href="#Some-helpful-functions-1" title="Permalink"></a></h2><h4 id="Creating-a-Region-Adjacency-Graph-(RAG)-1"><a class="docs-heading-anchor" href="#Creating-a-Region-Adjacency-Graph-(RAG)-1">Creating a Region Adjacency Graph (RAG)</a><a class="docs-heading-anchor-permalink" href="#Creating-a-Region-Adjacency-Graph-(RAG)-1" title="Permalink"></a></h4><p>A region adjacency graph can directly be constructed from a <code>SegmentedImage</code> using the <code>region_adjacency_graph</code> function. Each segment is denoted by a vertex and edges are constructed between adjacent segments. The output is a tuple of <code>SimpleWeightedGraph</code> and a <code>Dict(label=&gt;vertex)</code> with weights assigned according to <code>weight_fn</code>.</p><pre><code class="language-julia-repl">julia&gt; using ImageSegmentation, Distances, TestImages

julia&gt; img = testimage(&quot;camera&quot;);

julia&gt; seg = felzenszwalb(img, 10, 100);

julia&gt; weight_fn(i,j) = euclidean(segment_pixel_count(seg,i), segment_pixel_count(seg,j));

julia&gt; G, vert_map = region_adjacency_graph(seg, weight_fn);

julia&gt; G
{70, 139} undirected simple Int64 graph with Float64 weights</code></pre><p>Here, the difference in pixel count has been used as the weight of the connecting edges. This difference measure can be useful if one wants to use this region adjacency graph to remove smaller segments by merging them with their neighbouring largest segment. Another useful difference measure is the euclidean distance between the mean intensities of the two segments.</p><h4 id="Creating-a-Region-Tree-1"><a class="docs-heading-anchor" href="#Creating-a-Region-Tree-1">Creating a Region Tree</a><a class="docs-heading-anchor-permalink" href="#Creating-a-Region-Tree-1" title="Permalink"></a></h4><p>A region tree can be constructed from an image using <code>region_tree</code> function. If the image is not homogeneous, then it is split into half along each dimension and the function is called recursively for each portion of the image. The output is a <code>RegionTree</code>.</p><pre><code class="language-julia-repl">julia&gt; using ImageSegmentation

julia&gt; function homogeneous(img)
           min, max = extrema(img)
           max - min &lt; 0.2
       end
homogeneous (generic function with 1 method)

julia&gt; t = region_tree(img, homogeneous)        # `img` is an image
Cell: RegionTrees.HyperRectangle{2,Float64}([1.0, 1.0], [300.0, 300.0])</code></pre><p>For more information regarding <code>RegionTrees</code>, see <a href="https://github.com/rdeits/RegionTrees.jl#regiontreesjl-quadtrees-octrees-and-their-n-dimensional-cousins">this</a>.</p><h4 id="Pruning-unnecessary-segments-1"><a class="docs-heading-anchor" href="#Pruning-unnecessary-segments-1">Pruning unnecessary segments</a><a class="docs-heading-anchor-permalink" href="#Pruning-unnecessary-segments-1" title="Permalink"></a></h4><p>All the unnecessary segments can be easily removed from a <code>SegmentedImage</code> using <code>prune_segments</code>. It removes a segment by replacing it with the neighbor which has the least value of <code>diff_fn</code>. A list of the segments to be removed can be supplied. Alternately, a function can be supplied that returns <code>true</code> for the labels that must be removed.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The resultant <code>SegmentedImage</code> might have the different labels compared to the original <code>SegmentedImage</code>.</p></div></div><p>For this example and the next one (in <a href="#Removing-a-segment-1">Removing a segment</a>), a sample <code>SegmentedImage</code> has been used. It can be generated as:</p><pre><code class="language-julia-repl">julia&gt; img = fill(1, (4, 4));

julia&gt; img[3:4,:] .= 2;

julia&gt; img[1:2,3:4] .= 3;

julia&gt; seg = fast_scanning(img, 0.5);

julia&gt; labels_map(seg)
4×4 Array{Int64,2}:
 1  1  3  3
 1  1  3  3
 2  2  2  2
 2  2  2  2

julia&gt; seg.image_indexmap
4×4 Array{Int64,2}:
 1  1  3  3
 1  1  3  3
 2  2  2  2
 2  2  2  2

julia&gt; diff_fn(rem_label, neigh_label) = segment_pixel_count(seg,rem_label) - segment_pixel_count(seg,neigh_label);

julia&gt; new_seg = prune_segments(seg, [3], diff_fn);

julia&gt; labels_map(new_seg)
4×4 Array{Int64,2}:
 1  1  2  2
 1  1  2  2
 2  2  2  2
 2  2  2  2</code></pre><h4 id="Removing-a-segment-1"><a class="docs-heading-anchor" href="#Removing-a-segment-1">Removing a segment</a><a class="docs-heading-anchor-permalink" href="#Removing-a-segment-1" title="Permalink"></a></h4><p>If only one segment is to be removed, then <code>rem_segment!</code> can be used. It removes a segment from a <code>SegmentedImage</code> in place, replacing it with the neighbouring segment having least <code>diff_fn</code> value.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If multiple segments need to be removed then <a href="../../function_reference/#ImageSegmentation.prune_segments"><code>prune_segments</code></a> should be preferred as it is much more time efficient than calling <code>rem_segment!</code> multiple times.</p></div></div><pre><code class="language-julia-repl">julia&gt; seg.image_indexmap
4×4 Array{Int64,2}:
 1  1  3  3
 1  1  3  3
 2  2  2  2
 2  2  2  2

julia&gt; diff_fn(rem_label, neigh_label) = segment_pixel_count(seg,rem_label) - segment_pixel_count(seg,neigh_label);

julia&gt; rem_segment!(seg, 3, diff_fn);

julia&gt; labels_map(new_seg)
4×4 Array{Int64,2}:
 1  1  2  2
 1  1  2  2
 2  2  2  2
 2  2  2  2</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../metadata/">« ImageMetaData.jl</a><a class="docs-footer-nextpage" href="../transformations/">ImageTransformations.jl »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 4 July 2020 02:54">Saturday 4 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
