<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quickstart · JuliaImages</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../democards/gridtheme.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="JuliaImages logo"/></a><div class="docs-package-name"><span class="docs-autofit">JuliaImages</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../install/">Getting started</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Quickstart</a><ul class="internal"><li><a class="tocitem" href="#Images-are-just-arrays"><span>Images are just arrays</span></a></li><li><a class="tocitem" href="#Array-elements-are-pixels-(and-vice-versa)"><span>Array elements are pixels (and vice versa)</span></a></li><li><a class="tocitem" href="#Color-conversions-are-construction/view"><span>Color conversions are construction/view</span></a></li><li><a class="tocitem" href="#The-0-to-1-intensity-scale"><span>The 0-to-1 intensity scale</span></a></li><li><a class="tocitem" href="#Arrays-with-arbitrary-indices"><span>Arrays with arbitrary indices</span></a></li><li><a class="tocitem" href="#Function-categories"><span>Function categories</span></a></li></ul></li><li><a class="tocitem" href="../arrays_colors/">Arrays, Numbers, and Colors</a></li><li><a class="tocitem" href="../conversions_views/">Conversions vs. views</a></li><li><a class="tocitem" href="../indexing/">Arrays: more advanced indexing</a></li></ul></li><li><span class="tocitem">Packages</span><ul><li><a class="tocitem" href="../../pkgs/">Introduction</a></li><li><a class="tocitem" href="../../pkgs/axes/">ImageAxes.jl</a></li><li><a class="tocitem" href="../../pkgs/metadata/">ImageMetaData.jl</a></li><li><a class="tocitem" href="../../pkgs/segmentation/">ImageSegmentation.jl</a></li><li><a class="tocitem" href="../../pkgs/transformations/">ImageTransformations.jl</a></li><li><a class="tocitem" href="../../pkgs/features/">ImageFeatures.jl</a></li></ul></li><li><a class="tocitem" href="../../democards/examples/">Demos</a></li><li><a class="tocitem" href="../../function_reference/">References</a></li><li><a class="tocitem" href="../../api_comparison/">Comparison with other image processing frameworks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Quickstart</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quickstart</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaImages/juliaimages.github.io/blob/source/docs/src/tutorials/quickstart.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="page_quickstart"><a class="docs-heading-anchor" href="#page_quickstart">Quickstart</a><a id="page_quickstart-1"></a><a class="docs-heading-anchor-permalink" href="#page_quickstart" title="Permalink"></a></h1><p>If you&#39;re comfortable with Julia or have used another image-processing package before, this page may help you get started quickly. If some of the terms or concepts here seem strange, don&#39;t worry–-there are much more detailed explanations in the following sections.</p><h2 id="Images-are-just-arrays"><a class="docs-heading-anchor" href="#Images-are-just-arrays">Images are just arrays</a><a id="Images-are-just-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Images-are-just-arrays" title="Permalink"></a></h2><p>For most purposes, any <code>AbstractArray</code> can be treated as an image. For example, numeric array can be interpreted as a grayscale image.</p><pre><code class="language-julia-repl">julia&gt; img = rand(4, 3)
4×3 Array{Float64,2}:
 0.294863  0.603624   0.113032
 0.696311  0.0443766  0.670174
 0.332355  0.915681   0.140473
 0.415085  0.372323   0.0813266</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFcAAAB0CAAAAADVm/EoAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAABySURBVGje7dAxDYBQEERBPsECapBAQY0RDGCEBAcIwgMOcLAFCc1ltn3JFNvmLmxJcU+x7/4Zl8vlcrlcLvfb2pXqmuJR6Qcul8vlcrnc6u5wpnqnOFX6gcvlcrlcLre6O4ypbik+lX7gcrlcLpfLre6+Qf0G6xzfUnkAAAAASUVORK5CYII=" /><p>We could also select a region-of-interest from a larger image</p><pre><code class="language-julia"># generate an image that starts black in the upper left
# and gets bright in the lower right
img = Array(reshape(range(0,stop=1,length=10^4), 100, 100))
# make a copy
img_c = img[51:70, 21:70] # red
# make a view
img_v = @view img[16:35, 41:90] # blue</code></pre><img src="data:image/png;base64,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" /><p>As you might know, changing the value of a view would affect the original image, while changing that of a copy doesn&#39;t:</p><pre><code class="language-julia">fill!(img_c, 1) # red region in original doesn&#39;t change
fill!(img_v, 0) # blue</code></pre><img src="data:image/png;base64,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" /><p>Don&#39;t worry if you don&#39;t get the &quot;image&quot; result, that&#39;s expected and you&#39;ll learn how to automatically display an image later in JuliaImages.</p><p>Some add-on packages enable additional behavior. For example,</p><pre><code class="language-julia">using Unitful, AxisArrays
using Unitful: mm, s

img = AxisArray(rand(256, 256, 6, 50), (:x, :y, :z, :time), (0.4mm, 0.4mm, 1mm, 2s))</code></pre><p>defines a 4d image (3 space dimensions plus one time dimension) with the specified name and physical pixel spacing for each coordinate. The <a href="https://github.com/JuliaArrays/AxisArrays.jl"><code>AxisArrays</code></a> package supports rich and efficient operations on such arrays, and can be useful to keep track of not just pixel spacing but the <a href="http://www.grahamwideman.com/gw/brain/orientation/orientterms.htm">orientation convention used for multidimensional images</a>.</p><p>JuliaImages interoperates smoothly with <code>AxisArrays</code> and many other packages.  As further examples,</p><ul><li><p>the <a href="https://github.com/JuliaImages/ImageMetadata.jl"><code>ImageMetadata</code></a> package (incorporated into <code>Images</code> itself) allows you to &quot;tag&quot; images with custom metadata</p></li><li><p>the <a href="https://github.com/JuliaArrays/IndirectArrays.jl"><code>IndirectArrays</code></a> package supports indexed (colormap) images</p></li><li><p>the <a href="https://github.com/JuliaArrays/MappedArrays.jl"><code>MappedArrays</code></a> package allows you to represent <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy</a> value-transformations, facilitating work with images that may be too large to store in memory at once</p></li><li><p><a href="https://github.com/JuliaImages/ImageTransformations.jl"><code>ImageTransformations</code></a> allows you to encode rotations, shears, deformations, etc., either eagerly or lazily</p></li></ul><p>It is very easy to define new array types in Julia–and consequently specialized images or operations–and have them interoperate smoothly with the vast majority of functions in JuliaImages.</p><h2 id="Array-elements-are-pixels-(and-vice-versa)"><a class="docs-heading-anchor" href="#Array-elements-are-pixels-(and-vice-versa)">Array elements are pixels (and vice versa)</a><a id="Array-elements-are-pixels-(and-vice-versa)-1"></a><a class="docs-heading-anchor-permalink" href="#Array-elements-are-pixels-(and-vice-versa)" title="Permalink"></a></h2><p>Elements of image are called <strong>pixels</strong>; in JuliaImages we provide an abstraction on this concept. For example, we have <code>Gray</code> for grayscale image, <code>RGB</code> for RGB image, <code>Lab</code> for Lab image, and etc.</p><p>Creating a pixel is initializing a struct of that type:</p><pre><code class="language-julia">Gray(0.0) # black
Gray(1.0) # white
RGB(1.0, 0.0, 0.0) # red
RGB(0.0, 1.0, 0.0) # green
RGB(0.0, 0.0, 1.0) # blue</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAAAtBAMAAACqtxGGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAD1BMVEUAAAD/////AAAA/wAAAP8sQvYcAAAAAWJLR0QB/wIt3gAAADtJREFUWMPtzTEBACAMA7AhAQsgAQMc868JA725EgOpisaMVrRP1NEto9FoNBqNRqPRaDQajUaj0fh9fBVyox8IfnNyAAAAAElFTkSuQmCC" /><p>and image is just an array of pixel objects:</p><pre><code class="language-julia-repl">julia&gt; img_gray = rand(Gray, 2, 2)
2×2 Array{Gray{Float64},2} with eltype Gray{Float64}:
 Gray{Float64}(0.355822)  Gray{Float64}(0.682579)
 Gray{Float64}(0.165132)  Gray{Float64}(0.806625)

julia&gt; img_rgb = rand(RGB, 2, 2)
2×2 Array{RGB{Float64},2} with eltype RGB{Float64}:
 RGB{Float64}(0.708011,0.515411,0.608607)   …  RGB{Float64}(0.34124,0.52376,0.661835)
 RGB{Float64}(0.887999,0.494824,0.0895199)     RGB{Float64}(0.833012,0.498856,0.937867)

julia&gt; img_lab = rand(Lab, 2, 2)
2×2 Array{Lab{Float64},2} with eltype Lab{Float64}:
 Lab{Float64}(95.6888,28.6177,-119.44)  …  Lab{Float64}(6.8166,-73.164,-82.2067)
 Lab{Float64}(68.5393,45.6552,50.4171)     Lab{Float64}(17.0987,-4.13231,93.5434)</code></pre><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOYAAAAuBAMAAADO/3hRAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAJ1BMVEVbW1uurq7///+1g5tXhqkA8P8ANIsqKirOzs7ifhfUf+//gk1BKQBBAz5LAAAAAWJLR0QCZgt8ZAAAAF1JREFUWMPtzUEZQEAUReEnggoqEEEFIkyFEUEFIqhABKEsz8ZLMOes73f/COp6Gv4baZopWS+0FgpNTU1NTU1NTc02zErbTsnLQedFyfqm5yVNTU1NTU1NTc02zA/KWEw+JkEumAAAAABJRU5ErkJggg==" /><p>As you can see, both <code>img_rgb</code> and <code>img_lab</code> images are of size <span>$2 \times 2$</span> (instead of <span>$2 \times 2 \times 3$</span> or <span>$3 \times 2 \times 2$</span>); a RGB image is an array of <code>RGB</code> pixels whereas a Lab image is an array of <code>Lab</code> pixel.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It&#39;s recommended to use <code>Gray</code> instead of the <code>Number</code> type in JuliaImages since it indicates that the array of numbers is best interpreted as a grayscale image. For example, it triggers <code>Atom/Juno</code> and <code>Jupyter</code> to display the array as an image instead of a matrix of numbers. There&#39;s no performance overhead for using <code>Gray</code> over <code>Number</code>.</p></div></div><p>This design choice facilitates generic code that can handle both grayscale and color images without needing to introduce extra loops or checks for a color dimension. It also provides more rational support for 3d grayscale images–which might happen to have size 3 along the third dimension–and consequently helps unify the &quot;computer vision&quot; and &quot;biomedical image processing&quot; communities.</p><h2 id="Color-conversions-are-construction/view"><a class="docs-heading-anchor" href="#Color-conversions-are-construction/view">Color conversions are construction/view</a><a id="Color-conversions-are-construction/view-1"></a><a class="docs-heading-anchor-permalink" href="#Color-conversions-are-construction/view" title="Permalink"></a></h2><p>Conversions between different <code>Colorant</code>s are straightforward:</p><pre><code class="language-julia-repl">julia&gt; RGB.(img_gray) # Gray =&gt; RGB
2×2 Array{RGB{Float64},2} with eltype RGB{Float64}:
 RGB{Float64}(0.355822,0.355822,0.355822)  …  RGB{Float64}(0.682579,0.682579,0.682579)
 RGB{Float64}(0.165132,0.165132,0.165132)     RGB{Float64}(0.806625,0.806625,0.806625)

julia&gt; Gray.(img_rgb) # RGB =&gt; Gray
2×2 Array{Gray{Float64},2} with eltype Gray{Float64}:
 Gray{Float64}(0.583623)  Gray{Float64}(0.484927)
 Gray{Float64}(0.566179)  Gray{Float64}(0.648816)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You&#39;ll see <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting-1">broadcasting</a> semantics used in JuliaImages here and there, check the documentation if you&#39;re not familiar with it.</p></div></div><p>Sometimes, to work with other packages, you&#39;ll need to convert a <span>$m \times n$</span> <code>RGB</code> image to <span>$m \times n \times 3$</span> numeric array and vice versa. The functions <code>channelview</code> and <code>colorview</code> are designed for this purpose. For example:</p><pre><code class="language-julia-repl">julia&gt; img_CHW = channelview(img_rgb) # 3 * 2 * 2
3×2×2 reinterpret(Float64, ::Array{RGB{Float64},3}):
[:, :, 1] =
 0.708011  0.887999
 0.515411  0.494824
 0.608607  0.0895199

[:, :, 2] =
 0.34124   0.833012
 0.52376   0.498856
 0.661835  0.937867

julia&gt; img_HWC = permutedims(img_CHW, (2, 3, 1)) # 2 * 2 * 3
2×2×3 Array{Float64,3}:
[:, :, 1] =
 0.708011  0.34124
 0.887999  0.833012

[:, :, 2] =
 0.515411  0.52376
 0.494824  0.498856

[:, :, 3] =
 0.608607   0.661835
 0.0895199  0.937867</code></pre><pre><code class="language-julia-repl">julia&gt; img_CHW = permutedims(img_HWC, (3, 1, 2)) # 3 * 2 * 2
3×2×2 Array{Float64,3}:
[:, :, 1] =
 0.708011  0.887999
 0.515411  0.494824
 0.608607  0.0895199

[:, :, 2] =
 0.34124   0.833012
 0.52376   0.498856
 0.661835  0.937867

julia&gt; img_rgb = colorview(RGB, img_CHW) # 2 * 2
2×2 reshape(reinterpret(RGB{Float64}, ::Array{Float64,3}), 2, 2) with eltype RGB{Float64}:
 RGB{Float64}(0.708011,0.515411,0.608607)   …  RGB{Float64}(0.34124,0.52376,0.661835)
 RGB{Float64}(0.887999,0.494824,0.0895199)     RGB{Float64}(0.833012,0.498856,0.937867)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Don&#39;t overuse <code>channelview</code> because it loses the colorant information by converting an image to a raw numeric array.</p><p>It&#39;s very likely that users from other languages will have the tendency to <code>channelview</code> every image they&#39;re going to process. Unfamiliarity of the pixel concept provided by JuliaImages doesn&#39;t necessarily mean it&#39;s bad.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The reason we use CHW (i.e., channel-height-width) order instead of HWC is that this provides a memory friendly indexing mechanisim for <code>Array</code>. By default, in Julia the first index is also the fastest (i.e., has adjacent storage in memory). For more details, please refer to the performance tip: <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#Access-arrays-in-memory-order,-along-columns-1">Access arrays in memory order, along columns</a></p><p>You can use <code>PermutedDimsArray</code> to &quot;reinterpret&quot; the orientation of a chunk of memory without making a copy, or <code>permutedims</code> if you want a copy.</p></div></div><p>For <code>Gray</code> images, the following codes are almost equivalent except that the construction version copies the data while the view version doesn&#39;t.</p><pre><code class="language-julia">img_num = rand(4, 4)

img_gray_copy = Gray.(img_num) # construction
img_num_copy = Float64.(img_gray_copy) # construction

img_gray_view = colorview(Gray, img_num) # view
img_num_view = channelview(img_gray_view) # view</code></pre><h2 id="The-0-to-1-intensity-scale"><a class="docs-heading-anchor" href="#The-0-to-1-intensity-scale">The 0-to-1 intensity scale</a><a id="The-0-to-1-intensity-scale-1"></a><a class="docs-heading-anchor-permalink" href="#The-0-to-1-intensity-scale" title="Permalink"></a></h2><p>In JuliaImages, by default all images are displayed assuming that 0 means &quot;black&quot; and 1 means &quot;white&quot; or &quot;saturated&quot; (the latter applying to channels of an RGB image).</p><p>Perhaps surprisingly, <strong>this 0-to-1 convention applies even when the intensities are encoded using only 8-bits per color channel</strong>. JuliaImages uses a special type, <code>N0f8</code>, that interprets an 8-bit &quot;integer&quot; as if it had been scaled by 1/255, thus encoding values from 0 to 1 in 256 steps.</p><p><code>N0f8</code> numbers (standing for <strong>N</strong>ormalized, with <strong>0</strong> integer bits and <strong>8</strong> <strong>f</strong>ractional bits) obey standard mathematical rules, and can be added, multiplied, etc. There are types like <code>N0f16</code> for working with 16-bit images (and even <code>N2f14</code> for images acquired with a 14-bit camera, etc.).</p><pre><code class="language-julia-repl">julia&gt; img_n0f8 = rand(N0f8, 2, 2)
2×2 reinterpret(N0f8, ::Array{UInt8,2}):
 0.863  0.882
 0.275  0.071

julia&gt; float.(img_n0f8)
2×2 Array{Float32,2}:
 0.862745  0.882353
 0.27451   0.0705882</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This infrastructure allows us to unify &quot;integer&quot; and floating-point images, and avoids the need for special conversion functions (e.g., <code>im2double</code> in MATLAB) that change the <em>value</em> of pixels when your main goal is simply to change the <em>type</em> (numeric precision and properties) used to represent the pixel.</p></div></div><p>Although it&#39;s not recommended, but you can use <code>rawview</code> to get the underlying storage data and convert it to <code>UInt8</code> (or other types) if you insist.</p><pre><code class="language-julia-repl">julia&gt; img_n0f8_raw = rawview(img_n0f8)
2×2 rawview(reinterpret(N0f8, ::Array{UInt8,2})) with eltype UInt8:
 0xdc  0xe1
 0x46  0x12

julia&gt; float.(img_n0f8_raw)
2×2 Array{Float64,2}:
 220.0  225.0
  70.0   18.0</code></pre><p>Conversions between the storage type, i.e., the actual numeric type, without changing the color type are supported by the following functions:</p><ul><li><a href="../../function_reference/#ImageCore.float32"><code>float32</code></a>, <a href="../../function_reference/#ImageCore.float64"><code>float64</code></a></li><li><a href="../../function_reference/#ImageCore.n0f8"><code>n0f8</code></a>, <a href="../../function_reference/#ImageCore.n6f10"><code>n6f10</code></a>, <a href="../../function_reference/#ImageCore.n4f12"><code>n4f12</code></a>, <a href="../../function_reference/#ImageCore.n2f14"><code>n2f14</code></a>, <a href="../../function_reference/#ImageCore.n0f16"><code>n0f16</code></a></li></ul><pre><code class="language-julia-repl">julia&gt; img = rand(Gray{N0f8}, 2, 2)
2×2 Array{Gray{N0f8},2} with eltype Gray{Normed{UInt8,8}}:
 Gray{N0f8}(0.745)  Gray{N0f8}(0.635)
 Gray{N0f8}(0.22)   Gray{N0f8}(0.0)

julia&gt; img_float32 = float32.(img) # Gray{N0f8} =&gt; Gray{Float32}
2×2 Array{Gray{Float32},2} with eltype Gray{Float32}:
 Gray{Float32}(0.745098)  Gray{Float32}(0.635294)
 Gray{Float32}(0.219608)  Gray{Float32}(0.0)

julia&gt; img_n0f16 = n0f16.(img_float32) # Gray{Float32} =&gt; Gray{N0f16}
2×2 Array{Gray{N0f16},2} with eltype Gray{Normed{UInt16,16}}:
 Gray{N0f16}(0.7451)   Gray{N0f16}(0.63529)
 Gray{N0f16}(0.21961)  Gray{N0f16}(0.0)</code></pre><p>If you don&#39;t want to specify the destination type, <code>float</code> is designed for this:</p><pre><code class="language-julia-repl">julia&gt; img_n0f8 = rand(Gray{N0f8}, 2, 2)
2×2 Array{Gray{N0f8},2} with eltype Gray{Normed{UInt8,8}}:
 Gray{N0f8}(0.804)  Gray{N0f8}(0.643)
 Gray{N0f8}(0.345)  Gray{N0f8}(0.298)

julia&gt; img_float = float.(img_n0f8) # Gray{N0f8} =&gt; Gray{Float32}
2×2 Array{Gray{Float32},2} with eltype Gray{Float32}:
 Gray{Float32}(0.803922)  Gray{Float32}(0.643137)
 Gray{Float32}(0.345098)  Gray{Float32}(0.298039)</code></pre><p>For a view-like conversion without new memory allocation, <code>of_eltype</code> in <a href="https://github.com/JuliaArrays/MappedArrays.jl"><code>MappedArrays</code></a> is designed for this:</p><pre><code class="language-julia-repl">julia&gt; using MappedArrays

julia&gt; img_float_view = of_eltype(Gray{Float32}, img_n0f8)
2×2 mappedarray(x-&gt;MappedArrays.convert($(Expr(:static_parameter, 1)), x), y-&gt;MappedArrays.convert($(Expr(:static_parameter, 1)), y), ::Array{Gray{N0f8},2}) with eltype Gray{Float32}:
 Gray{Float32}(0.803922)  Gray{Float32}(0.643137)
 Gray{Float32}(0.345098)  Gray{Float32}(0.298039)

julia&gt; eltype(img_float_view)
Gray{Float32}</code></pre><h2 id="Arrays-with-arbitrary-indices"><a class="docs-heading-anchor" href="#Arrays-with-arbitrary-indices">Arrays with arbitrary indices</a><a id="Arrays-with-arbitrary-indices-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays-with-arbitrary-indices" title="Permalink"></a></h2><p>If you have an input image and perform some kind of spatial transformation on it, how do pixels/voxels in the transformed image match up to pixels in the input? Through Julia&#39;s support for arrays with indices that start at values other than 1, it is possible to allow array indices to represent <em>absolute</em> position in space, making it straightforward to keep track of the correspondence between location across multiple images. More information can be found in <a href="../indexing/#Keeping-track-of-location-with-unconventional-indices">Keeping track of location with unconventional indices</a>.</p><h2 id="Function-categories"><a class="docs-heading-anchor" href="#Function-categories">Function categories</a><a id="Function-categories-1"></a><a class="docs-heading-anchor-permalink" href="#Function-categories" title="Permalink"></a></h2><p>See <a href="../../function_reference/#page_references">Summary and function reference</a> for more information about each of the topics below. The list below is accessible via <code>?Images</code> from the Julia REPL. If you&#39;ve used other frameworks previously, you may also be interested in the <a href="../../api_comparison/#page_api_comparison">Comparison with other image processing frameworks</a>. Also described are the <a href="../../pkgs/features/#ImageFeatures.jl">ImageFeatures.jl</a> and <a href="../../pkgs/segmentation/#ImageSegmentation.jl">ImageSegmentation.jl</a> packages, which support a number of algorithms important for computer vision.</p><p>Constructors, conversions, and traits:</p><ul><li>Construction: use constructors of specialized packages, e.g., <code>AxisArray</code>, <code>ImageMeta</code>, etc.</li><li>&quot;Conversion&quot;: <code>colorview</code>, <code>channelview</code>, <code>rawview</code>, <code>normedview</code>, <code>permuteddimsview</code>, <code>paddedviews</code></li><li>Traits: <code>pixelspacing</code>, <code>sdims</code>, <code>timeaxis</code>, <code>timedim</code>, <code>spacedirections</code></li></ul><p>Contrast/coloration:</p><ul><li><code>clamp01</code>, <code>clamp01nan</code>, <code>scaleminmax</code>, <code>colorsigned</code>, <code>scalesigned</code></li></ul><p>Algorithms:</p><ul><li>Reductions: <code>maxfinite</code>, <code>maxabsfinite</code>, <code>minfinite</code>, <code>meanfinite</code>, <code>sad</code>, <code>ssd</code>, <code>integral_image</code>, <code>boxdiff</code>, <code>gaussian_pyramid</code></li><li>Resizing and spatial transformations: <code>restrict</code>, <code>imresize</code>, <code>warp</code></li><li>Filtering: <code>imfilter</code>, <code>imfilter!</code>, <code>imfilter_LoG</code>, <code>mapwindow</code>, <code>imROF</code>, <code>padarray</code></li><li>Filtering kernels: <code>Kernel.</code> or <code>KernelFactors.</code>, followed by <code>ando[345]</code>, <code>guassian2d</code>, <code>imaverage</code>, <code>imdog</code>, <code>imlaplacian</code>, <code>prewitt</code>, <code>sobel</code></li><li>Exposure : <code>build_histogram</code>, <code>adjust_histogram</code>, <code>imadjustintensity</code>, <code>imstretch</code>, <code>imcomplement</code>, <code>AdaptiveEqualization</code>, <code>GammaCorrection</code>, <code>cliphist</code></li><li>Gradients: <code>backdiffx</code>, <code>backdiffy</code>, <code>forwarddiffx</code>, <code>forwarddiffy</code>, <code>imgradients</code></li><li>Edge detection: <code>imedge</code>, <code>imgradients</code>, <code>thin_edges</code>, <code>magnitude</code>, <code>phase</code>, <code>magnitudephase</code>, <code>orientation</code>, <code>canny</code></li><li>Corner detection: <code>imcorner</code>, <code>harris</code>, <code>shi_tomasi</code>, <code>kitchen_rosenfeld</code>, <code>meancovs</code>, <code>gammacovs</code>, <code>fastcorners</code></li><li>Blob detection: <code>blob_LoG</code>, <code>findlocalmaxima</code>, <code>findlocalminima</code></li><li>Morphological operations: <code>dilate</code>, <code>erode</code>, <code>closing</code>, <code>opening</code>, <code>tophat</code>, <code>bothat</code>, <code>morphogradient</code>, <code>morpholaplace</code>, <code>feature_transform</code>, <code>distance_transform</code></li><li>Connected components: <code>label_components</code>, <code>component_boxes</code>, <code>component_lengths</code>, <code>component_indices</code>, <code>component_subscripts</code>, <code>component_centroids</code></li><li>Interpolation: <code>bilinear_interpolation</code></li></ul><p>Test images and phantoms (see also TestImages.jl):</p><ul><li><code>shepp_logan</code></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../install/">« Getting started</a><a class="docs-footer-nextpage" href="../arrays_colors/">Arrays, Numbers, and Colors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 15 September 2020 02:15">Tuesday 15 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
