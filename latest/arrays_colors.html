<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Arrays, Numbers, and Colors · JuliaImages</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="JuliaImages logo"/></a><h1>JuliaImages</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="install.html">Getting started: Installation and testing your install</a></li><li><a class="toctext" href="quickstart.html">Quickstart</a></li><li class="current"><a class="toctext" href="arrays_colors.html">Arrays, Numbers, and Colors</a><ul class="internal"><li><a class="toctext" href="#Numbers-versus-colors-1">Numbers versus colors</a></li><li><a class="toctext" href="#Colors-beyond-the-pale-1">Colors beyond the pale</a></li><li><a class="toctext" href="#A-consistent-scale-for-floating-point-and-&quot;integer&quot;-colors:-fixed-point-numbers-1">A consistent scale for floating-point and &quot;integer&quot; colors: fixed-point numbers</a></li><li><a class="toctext" href="#More-fixed-point-numbers-1">More fixed-point numbers</a></li><li><a class="toctext" href="#A-note-on-arithmetic-overflow-1">A note on arithmetic overflow</a></li></ul></li><li><a class="toctext" href="conversions_views.html">Conversions vs. views</a></li><li><a class="toctext" href="indexing.html">Arrays: more advanced indexing</a></li><li><a class="toctext" href="imageaxes.html">ImageAxes.jl</a></li><li><a class="toctext" href="imagefiltering.html">ImageFiltering.jl</a></li><li><a class="toctext" href="imagemetadata.html">ImageMetadata.jl</a></li><li><a class="toctext" href="imagesegmentation.html">ImageSegmentation.jl</a></li><li><a class="toctext" href="imagefeatures.html">ImageFeatures.jl</a></li><li><a class="toctext" href="troubleshooting.html">Installation troubleshooting</a></li><li><a class="toctext" href="function_reference.html">Summary and function reference</a></li><li><a class="toctext" href="api_comparison.html">Comparison with other image processing frameworks</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="arrays_colors.html">Arrays, Numbers, and Colors</a></li></ul><a class="edit-page" href="https://github.com/JuliaImages/juliaimages.github.io/blob/source//docs/src/arrays_colors.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Arrays, Numbers, and Colors</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Arrays,-Numbers,-and-Colors-1" href="#Arrays,-Numbers,-and-Colors-1">Arrays, Numbers, and Colors</a></h1><p>In Julia, an image is just an array, and many of the ways you manipulate images come from the general methods to work with <a href="http://docs.julialang.org/en/stable/manual/arrays/">multidimensional arrays</a>. For example,</p><pre><code class="language-julia">julia&gt; img = rand(2,2)
2×2 Array{Float64,2}:
 0.366796  0.210256
 0.523879  0.819338</code></pre><p>defines an &quot;image&quot; <code>img</code> of 64-bit floating-point numbers. You should be able to use this as an image in most or all functions in JuliaImages.</p><p>We&#39;ll be talking quite a bit about handling arrays. This page will focus on the &quot;element type&quot; (<code>eltype</code>) stored in the array. In case you&#39;re new to Julia, if <code>a</code> is an array of integers:</p><pre><code class="language-julia">julia&gt; a = [1,2,3,4]
4-element Array{Int64,1}:
 1
 2
 3
 4</code></pre><p>then all of the following create a new array where the element type is <code>Float64</code>:</p><pre><code class="language-julia">convert(Array{Float64}, a)
map(Float64, a)
Float64.(a)     # short for broadcast(Float64, a)</code></pre><p>For example,</p><pre><code class="language-julia">julia&gt; Float64.(a)
4-element Array{Float64,1}:
 1.0
 2.0
 3.0
 4.0</code></pre><p>Arrays are indexed with square brackets (<code>a[1]</code>), with indexing starting at 1 by default. A two-dimensional array like <code>img</code> can be indexed as <code>img[2,1]</code>, which would be the second row, first column. Julia also supports &quot;linear indexing,&quot; using a single integer to address elements of an arbitrary multidimensional array in a manner that (in simple cases) reflects the memory offset of the particular element. For example, <code>img[3]</code> corresponds to <code>img[1,2]</code> (numbering goes down columns, and then wraps around at the top of the next column, because Julia arrays are stored in &quot;column major&quot; order where the fastest dimension is the first dimension).</p><h2><a class="nav-anchor" id="Numbers-versus-colors-1" href="#Numbers-versus-colors-1">Numbers versus colors</a></h2><p>For the array <code>img</code> we created above, you can display it as a grayscale image using ImageView. But if you&#39;re following along in IJulia, you might notice that <code>img</code> does not <em>display</em> as an image: instead, it prints as an array of numbers as shown above.  Arrays of &quot;plain numbers&quot; are not displayed graphically, because they might represent something numerical (e.g., a matrix used for linear algebra) rather than an image. To indicate that this is worthy of graphical display, convert the element type to a color chosen from the <a href="https://github.com/JuliaGraphics/Colors.jl">Colors</a> package:</p><p><img src="assets/arrays_colors/float_gray.png" alt="float_gray"/></p><p>Here we used <code>Gray</code> to indicate that this array should be interpreted as a grayscale image.</p><p>Under the hood, what is <code>Gray</code> doing?  It&#39;s informative to see the &quot;raw&quot; object, displayed as text:</p><p><img src="assets/arrays_colors/float_gray_text.png" alt="float_gray_text"/></p><p>(<strong>should there be a convenience function for this?</strong>) (Users of the Julia command-line REPL interface will see this representation immediately, rather than the graphical one.)</p><p>You can see this is a 2×2 array of <code>Gray{Float64}</code> objects. You might be curious how these <code>Gray</code> objects are represented. In the command-line REPL, it looks like this (the same command works with IJulia):</p><pre><code class="language-julia">julia&gt; dump(imgg[1,1])
ColorTypes.Gray{Float64}
  val: Float64 0.36679641243992434</code></pre><p><code>dump</code> shows the &quot;internal&quot; representation of an object.  You can see that <code>Gray</code> is a <a href="http://docs.julialang.org/en/stable/manual/types/">type</a> (technically, an <code>immutable</code>) with a single field <code>val</code>; for <code>Gray{Float64}</code>, <code>val</code> is a 64-bit floating point number. Using <code>val</code> directly is not recommended: you can extract the <code>Float64</code> value with the accessor functions <code>real</code> or <code>gray</code> (the reason for the latter name will be clearer when we discuss RGB colors).</p><p>What kind of overhead do these objects incur?</p><pre><code class="language-julia">julia&gt; sizeof(img)
32

julia&gt; sizeof(imgg)
32</code></pre><p>The answer is &quot;none&quot;: they don&#39;t take up any memory of their own, nor do they typically require any additional processing time. The <code>Gray</code> &quot;wrapper&quot; is just an &quot;interpretation&quot; of the values, one that helps clarify that this should be displayed as a grayscale image.  Indeed, <code>img</code> and <code>imgg</code> compare as equal:</p><pre><code class="language-julia">julia&gt; img == imgg
true</code></pre><p>There&#39;s more to say on this topic, but we&#39;ll wait until we discuss <a href="conversions_views.html#Conversions-vs.-views-1">Conversions vs. views</a>.</p><h2><a class="nav-anchor" id="Colors-beyond-the-pale-1" href="#Colors-beyond-the-pale-1">Colors beyond the pale</a></h2><p><code>Gray</code> is not the only color in the universe:</p><p><img src="assets/arrays_colors/randrgb.png" alt="randrgb"/></p><p>Let&#39;s look at <code>imgc</code> as text (shown here in the REPL):</p><pre><code class="language-julia">julia&gt; imgc
2×2 Array{ColorTypes.RGB{Float32},2}:
 RGB{Float32}(0.75509,0.965058,0.65486)     RGB{Float32}(0.696203,0.142474,0.783316)
 RGB{Float32}(0.705195,0.953892,0.0744661)  RGB{Float32}(0.571945,0.42736,0.548254)

julia&gt; size(imgc)
(2,2)

julia&gt; dump(imgc[1,1])
ColorTypes.RGB{Float32}
  r: Float32 0.7550899
  g: Float32 0.9650581
  b: Float32 0.65485954</code></pre><p>Here we see one of the primary differences between Julia&#39;s approach to images and that of several other popular frameworks: <code>imgc</code> does not have a dimension of the array devoted to the &quot;color channel.&quot; Instead, every element of the array corresponds to a complete pixel&#39;s worth of information. Often this simplifies the logic of many algorithms, sometimes allowing a single implementation to work for both color and grayscale images.</p><p>You can extract the individual color channels using their field names (<code>r</code>, <code>g</code>, and <code>b</code>), but as you&#39;ll see in a moment, a more universal approach is to use accessor functions:</p><pre><code class="language-julia">julia&gt; c = imgc[1,1]; (red(c), green(c), blue(c))
(0.7550899f0,0.9650581f0,0.65485954f0)</code></pre><p>Julia&#39;s Colors package allows the same color to be represented in several different ways, and this can facilitate interaction with other tools. For example, certain C libraries permit or prefer the order of the color channels to be different:</p><pre><code class="language-julia">julia&gt; dump(convert(BGR, c))
ColorTypes.BGR{Float32}
  b: Float32 0.65485954
  g: Float32 0.9650581
  r: Float32 0.7550899</code></pre><p>or even to pack the red, green, and blue colors–-together with a dummy &quot;alpha&quot; (transparency) channel–-into a single 32-bit integer:</p><pre><code class="language-julia">julia&gt; c24 = convert(RGB24, c); dump(c24)
ColorTypes.RGB24
  color: UInt32 12711591

julia&gt; c24.color
0x00c1f6a7</code></pre><p>From first (the first two hex-digits after the &quot;0x&quot;) to last (the final two hex-digits), the order of the channels here is alpha, red, green, blue:</p><pre><code class="language-julia">julia&gt; 0xc1/0xff
0.7568627450980392

julia&gt; 0xf6/0xff
0.9647058823529412

julia&gt; 0xa7/0xff
0.6549019607843137</code></pre><p>These values are close to the channels of <code>c</code>, but have been rounded off–-each channel is encoded with only 8 bits, so some approximation of the exact floating-point value is unavoidable.</p><h2><a class="nav-anchor" id="A-consistent-scale-for-floating-point-and-&quot;integer&quot;-colors:-fixed-point-numbers-1" href="#A-consistent-scale-for-floating-point-and-&quot;integer&quot;-colors:-fixed-point-numbers-1">A consistent scale for floating-point and &quot;integer&quot; colors: fixed-point numbers</a></h2><p><code>c24</code> does not have an <code>r</code> field, but we can still use <code>red</code> to extract the red channel:</p><pre><code class="language-julia">julia&gt; r = red(c24)
0.757N0f8</code></pre><p>This may look fairly strange at first, so let&#39;s unpack this carefully. Notice first that the &quot;floating-point&quot; portion of this number matches (to within the precision of the rounding) the value of <code>red(c)</code>. The <code>N0f8</code> means &quot;<strong>N</strong>ormalized with <strong>8 f</strong>ractional bits, with <strong>0</strong> bits left for representing values higher than 1.&quot; This is a <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed-point number</a>–-rather like floating-point numbers, except that the decimal does not &quot;float&quot;. Internally, these are represented in terms of the 8-bit unsigned integer <code>UInt8</code></p><pre><code class="language-julia">julia&gt; dump(r)
FixedPointNumbers.Normed{UInt8,8}
  i: UInt8 193</code></pre><p>(Note that <code>N0f8</code> is an abbreviation; the full typename is <code>Normed{UInt8, 8}</code>.) <code>N0f8</code> <em>interprets</em> this 8-bit integer as a value lying between 0 and 1, with 0 corresponding to <code>0x00</code> and 1 corresponding to <code>0xff</code>. This interpretation affects how the number is used for arithmetic and conversion to and from other values. Stated another way, <code>r</code> behaves as</p><pre><code class="language-julia">julia&gt; r == 193/255
true</code></pre><p>for essentially all purposes (but see <a href="arrays_colors.html#A-note-on-arithmetic-overflow-1">A note on arithmetic overflow</a>).</p><p>This has a very important consequence: <strong>in many other image frameworks, the &quot;meaning&quot; of an image depends on how it is stored, but in Julia the meaning can be assigned independently of storage representation.</strong> For example, in a different language/framework, the following sequence:</p><pre><code class="language-none">img = uint8(255*rand(10, 10, 3));
figure; image(img)
imgd = double(img);   % convert to double-precision, but don&#39;t change the values
figure; image(imgd)</code></pre><p>might produce the following images:</p><table><tr><th>img</th><th>imgd</th></tr><tr><td><img src="assets/arrays_colors/uint8.png" alt="checker"/></td><td><img src="assets/arrays_colors/uint8_to_double.png" alt="checker2"/></td></tr></table><p>The one on the right looks white because floating-point types are interpreted on a 0-to-1 colorscale, whereas <code>uint8</code> is interpreted on a 0-to-255 colorscale.</p><p>Many frameworks offer convenience functions for converting images from one representation to another, but this can be a source of bugs if we go to compare images: in most number systems we would agree that <code>255 != 1.0</code>, and this fact means that you sometimes need to be quite careful when converting from one representation to another. Conversely, using these Julia packages <strong>there is no discrepancy in &quot;meaning&quot; between the encoding of images represented as floating point or 8-bit (or 16-bit) fixed-point numbers: 0 always means &quot;black&quot; and 1 always means &quot;white&quot; or &quot;saturated.&quot;</strong></p><p>Now, this doesn&#39;t prevent you from constructing pixels with values out of this range:</p><p><img src="assets/arrays_colors/saturated_spectrum.png" alt="saturated_spectrum"/></p><p>Notice that the first two yellows look identical, because both the red and green color channels are 1 or higher and consequently are saturated.</p><p>However, you should be aware that for <em>integer</em> inputs, the default is to use the <code>N0f8</code> element type, and this type cannot represent values outside the range from 0 to 1:</p><pre><code class="language-julia">julia&gt; RGB(8,2,0)
ERROR: ArgumentError: (8,2,0) are integers in the range 0-255, but integer inputs are encoded with the N0f8
  type, an 8-bit type representing 256 discrete values between 0 and 1.
  Consider dividing your input values by 255, for example: RGB{N0f8}(8/255,2/255,0/255)
  See the READMEs for FixedPointNumbers and ColorTypes for more information.
 in throw_colorerror(::Type{FixedPointNumbers.Normed{UInt8,8}}, ::Tuple{Int64,Int64,Int64}) at /home/tim/.julia/v0.5/ColorTypes/src/types.jl:639
 in throw_colorerror(::Type{FixedPointNumbers.Normed{UInt8,8}}, ::Int64, ::Int64, ::Int64) at /home/tim/.julia/v0.5/ColorTypes/src/types.jl:608
 in checkval at /home/tim/.julia/v0.5/ColorTypes/src/types.jl:596 [inlined]
 in ColorTypes.RGB{FixedPointNumbers.Normed{UInt8,8}}(::Int64, ::Int64, ::Int64) at /home/tim/.julia/v0.5/ColorTypes/src/types.jl:90
 in ColorTypes.RGB{T&lt;:Union{AbstractFloat,FixedPointNumbers.FixedPoint}}(::Int64, ::Int64, ::Int64) at /home/tim/.julia/v0.5/ColorTypes/src/types.jl:437</code></pre><p>The error message here reminds you how to resolve a common mistake, trying to construct red as <code>RGB(255, 0, 0)</code>. In Julia, that should always be <code>RGB(1, 0, 0)</code>.</p><h2><a class="nav-anchor" id="More-fixed-point-numbers-1" href="#More-fixed-point-numbers-1">More fixed-point numbers</a></h2><p>16-bit images can be expressed in terms of the <code>N0f16</code> type. Let&#39;s compare the maximum values (<code>typemax</code>) and smallest-difference (<code>eps</code>) representable with <code>N0f8</code> and <code>N0f16</code>:</p><pre><code class="language-julia">julia&gt; using FixedPointNumbers

julia&gt; (typemax(N0f8), eps(N0f8))
(1.0N0f8,0.004N0f8)

julia&gt; (typemax(N0f16), eps(N0f16))
(1.0N0f16,2.0e-5N0f16)</code></pre><p>You can see that this type also has a maximum value of 1, but is higher precision, with the gap between adjacent numbers being much smaller.</p><p>Many cameras (particularly, scientific cameras) now return 16-bit values. However, some cameras do not provide a full 16 bits worth of information; for example, the camera might be 12-bit and return values between <code>0x0000</code> and <code>0x0fff</code>.  As an <code>N0f16</code>, the latter displays as nearly black:</p><p><img src="assets/arrays_colors/12bit_black.png" alt="12bit_black"/></p><p>Since the camera is saturated, this is quite misleading–-it should instead display as white.</p><p>This again illustrates one of the fundamental problems about assuming that the <em>representation</em> (a 16-bit integer) also describes the <em>meaning</em> of the number. In Julia, we decouple these by providing many different fixed-point number types. In this case, the natural way to interpret these values is by using a fixed-point number with 12 fractional bits; this leaves 4 bits that we can use to represent values bigger than 1, so the number type is called <code>N4f12</code>:</p><pre><code class="language-julia">julia&gt; (typemax(N4f12), eps(N4f12))
(16.0037N4f12,0.0002N4f12)</code></pre><p>You can see that the maximum value achievable by an <code>N4f12</code> is approximately 16 = 2^4.</p><p>Using this <code>N4f12</code> interpretation of the 16 bits, the color displays correctly as white:</p><p><img src="assets/arrays_colors/12bit_white.png" alt="12bit_black"/></p><p>and acts like 1 for all arithmetic purposes. Even though the raw representation as <code>0x0fff</code> is the same, we can endow the number with appropriate meaning through its type.</p><h2><a class="nav-anchor" id="A-note-on-arithmetic-overflow-1" href="#A-note-on-arithmetic-overflow-1">A note on arithmetic overflow</a></h2><p>Sometimes, being able to construct a color values outside 0 to 1 is useful. For example, if you want to compute the average color in an image, the natural approach is to first sum all the pixels and then divide by the total number of pixels. At an intermediate stage, the sum will typically result in a color that is well beyond saturation.</p><p>It&#39;s important to note that arithmetic with <code>N0f8</code> numbers, like arithmetic with <code>UInt8</code>, overflows:</p><pre><code class="language-julia">julia&gt; 0xff + 0xff
0xfe

julia&gt; 0xfe/0xff
0.996078431372549

julia&gt; 1N0f8 + 1N0f8
0.996N0f8</code></pre><p>Consequently, if you&#39;re accumulating values, it&#39;s advisable to accumulate them in an appropriate floating-point type, such as <code>Float32</code>, <code>Gray{Float64}</code>, or <code>RGB{Float32}</code>.</p><footer><hr/><a class="previous" href="quickstart.html"><span class="direction">Previous</span><span class="title">Quickstart</span></a><a class="next" href="conversions_views.html"><span class="direction">Next</span><span class="title">Conversions vs. views</span></a></footer></article></body></html>
